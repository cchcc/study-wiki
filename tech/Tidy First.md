# Tidy First

https://tidyfirst.bettercode.kr/

## intro
- Tidy vs 기능(동작)
- 코드 정리(Tidy)를 먼저할까? 기능(동작)을 먼저 할까?
- 코드를 변경해야하는데.. 엉망이네 코드 정리부터 하는게 좋을까? 한다면 뭐부터? 어디까지?
  - 이책에서는 위같은 상황에서 이걸 잘 하는 방법을 이야기함

- '경험적' 소프트웨어 설계
  - 무엇 을 설계할것인가가 가장 큰 논쟁
  - 위 논쟁에서 근본적으로 언제 설계할것인가의 의견 차이가 생김
    - 극단적으로 최대한 빨리 설계: 추측형. 일어날 만한것들을 다 추측해서 설계에 녹여냄
    - 극단적으로 최대한 늦게 설계: 반응현. 기능위주로 하다가 기능 추가가 불가능해지는 시기에 그게 해소될 정도로만 설계해서 보완함
  - 언제 설계 할것인가. 위 두가지 사이의 그 어딘가를, 그 시기를 설계하는것

## p1 코드 정리

### 01 보호 구문
- 일찍 리턴 시키기
```
if (조건 부정) return
if (다른 조건의 부정) return  // 이런 것들을 보호 구문이라고 명칭
```
- 보호구문을 과한건 아닌가? 여기서 보호구문으로 이정도까지 책임져주는게 맞나? 하는 고민도 필요하다
  - 레이어 별 책임
- 보호구문으로 코드의 인지 범위를 집중화 시켜줌

### 02 안쓰는 코드
- 칼 삭, 미련 nono
- 형상 관리를 하고 있으면 복원하기 쉽다
  - 당장 사용하지 않지만 미래에 사용할지도..?
  - 잘 동작 하는거
  - 만들었는데 지우기 아까움..?
  - 지워도 안전하다 라는 확신을 가지려면 undo 에 대한 매카니즘이 있어야함
- 안쓰는 코드를 남겨두었다가 나중에 설계가 변해서 딱 맞지 않는데도 그대로 쓸 가능성이 있다
- 이슈가 생겼을때 안쓰는 코드가 있으면 디버깅하기 까다롭다(이게 쓰이는건지 뭔지..)
  - 이걸 판단하고 고민하는데 '시간' 이 든다
- 안쓰는 라이브러리 제거
  - go 는 언어 차원에서 의존성 관리 툴((Go Module)이 있고, tidy 라는 안쓰는 의존성을 제거해주는 명령어가 있다.

### 03 대칭으로 맞추기
- '대칭' 이라는 단어를 썼지만 일관성에 관한 이야기
  - 일관성덕에 코드를 파악하는데 시간을 조금이라도 줄여주는가
- 코드는 유기적으로 성장한다 -> 뭔소리냐면 같이 코드를 짜는 사람들의 관계도 코드에 반영된다
  - '유기적'이라는 단어에 초점하여 수직적으로 보면 코드가 해결하는 문제는 상위의 비지니스가 가치를 주는 일부이다
- 같은 문제라도 시대와 사람에 따라 다른 모양의 코드가 된다.
  - 혼자 코드를 짜도 같은 문제에 다른 패턴의 코드가 나오기도 한다.
  - 예를 들어 늦은 초기화, 즉 이전 객체가 없으면 새로 만들고 리턴 한다는 문제도 매우 다양한 패턴(뭔가 기교를 부린다거나)으로 만들어 질수 있다
- 이걸 한가지 패턴으로 맞추자. 코드를 읽는 입장에서 일관된 패턴이 나올수록 빠르게 사고 할수 있다
- 다른 패턴이 보이는거를 한가지 패턴으로 코치는 작업을 진행 하자
- 자동화
  - 린트라던가
- 코딩 표준화?
  - 고려할게 꽤 많고 사람에 따라서는 민감한 문제
  - 사람이 얼마나 있나? 코딩 스타일이 얼마나 비슷? 팀원들이 표준화를 원하나? 본인 스타일을 포기할 준비가 되있나?(강요로 억지로 따르게 되는게 맞나?)
  - 스타트업 같이 빠르게 mvp 를 만들고 pmf 를 맞춰나가는게 중요하면 생산성을 최대한 발휘하는게 나은 선택일수 있다
  - 자율성 창의성이 주어질수록 주도적으로 일하는 경향 고려
- 코드의 일관화 보다 아키텍쳐 수준에서 일관화가 좀더 에측/판단에 좀더 효율적

### 04 새로운 인터페이스로 기존 루틴 부르기
- 기존꺼를 호출하려는데 복잡, 어렵, 혼란, 지루(?) 하다면 새로 만들어보기
  - 지루하다는게.. 개인능력이 높아서 
- 어댑터, 파사드 패턴 비슷
- 다른 비슷한 느낌의 기법
  - 거꾸로 코딩: 함수의 마지막줄. 리턴해야 되는걸 먼저짜보기
  - 테스트 퍼스트: 테스트 코딩부터 짜보기
  - 도우미 설계: 
    - 헬퍼 vs 유틸
      - 공통점: 둘다 주요한 로직이 아닌 기능성 동작을 작성하는데 이 이름을 붙임
      - 다른점: 헬퍼는 static 뿐만 아니라 객체화도 가능, 내부 필드 가질수 있음. 유틸은 오로지 static 만 사용함

#### 몰입 이론(Flow Theory)
- 일의 어려운 정도 : 개인의 능력
- 위 두가지를 xy 그래프로 잡았을때 그 비율이 맞을때 몰입 할수 있다는..

### 05 읽는 순서
- 독자의 입장에서 코드를 작성하자: 읽는 순서를 고려해서 작성하자
  - 전체를 이해하는데 중요한 사항이 마지막에 오는게 좋은 방법일까?
  - 코드가 목적에 맞게 동작하는가(실행한다)와 코드가 깨끗한가(잘 나타있는가) 는 다른 문제
- 코드 작성의 목적(다른 사람이 읽게되는 목적)에 코드 정리 작업을 섞지 말자
  - 이건 PR 단위로 하는게 맞을듯
- 언어에 따라 선언하는 순서에 따라 결과가 달라지는 경우도 있다. 이런 경우는 주의
- 완벽한 순서를 정하는 방법은 없다
  - 기본 요소를 이해후 구성 방법을 하는게 좋을때도, api 먼저 이해후 세부구현을 이해하는게 좋을때도
  - 어떤 순서의 코드가 이해하는데 좋을지 
- 코드의 가독성: 사람의 인지 부하를 낮추는 방법
- 잘 정돈된 코드는 그 다음사람으로 하여금 비슷한 패턴으로 작성되도록 한다
- 이런것들 고민할 시간에 피쳐 하나라도 더 만드는게 의미 있는거 아닌가?
  - 궁극적으로는 이런 행동들이 몸에 베여 고민할 시간 들이지 않고 자연스럽게 나오도록 훈련이 필요(내)
- 실천적 방법들
  - A 함수에서 B 함수를 호출한다면 B 함수는 A 함수 바로 밑에다 작성
  - 개념단위를 행으로 구분
  - 밀접한 개념은 서로 가까이에 두기
  - 변수는 사용하는 위치에 최대한 가까이 두기
  - 이러한 것들들의 패턴을 일관되게 유지

### 06 응집도를 높이는 배치
- 코드를 변경하려고 했더니 여기저기 흩어져 있다면? -> 변경할 것들은 최대한 가까운 위치에 배치. 같은 파일, 같은 디렉토리
- 결합도 제거 + 변경 하는 비용 < 결합도 유지 + 변경 비용 ??
- 결합도를 제거하기 어려운 이유
  - 당장 어떻게 할지 모르는 경우
  - 시간적 여유가 없을때
  - 팀원 간의 잠재적 갈등 - 설계가 자주 바뀌어 적응 못한다거나 못 받아 들인다거나..
    - 팀에 스트레스를 줄수 있는 상황이면 안하는게 나을지도
- 응집도를 모은다고 해봣더니 나중에 알고보면 결합도만 들어나느경우? -> 문맥의 경계를 잘 정의 해야함
- 같은 이유로 변경되는 것을 모은다(SRP 비슷), 의존성을 낮춘다, 외부에 불필요한 정보는 private(캡슐화) -> 응집도를 높인다
- 