## 좋은 테스트
- 100% 코드 커버리지가 중요한 게 아니다. - 커버리지에 대한 강박관념은 버리고 의미 있는 테스트를 작성하는 데 집중하자.  
- 품질 보증 수단을 넘어 코드의 설계 수단으로 이용하자. - `테스트 → 코딩 → 설계(리팩토링)`
- TDD에서 BDD로 - `(scenario) → given → when → then → (clean)`
- 읽기 쉽고, 찾기 쉽고, 이해하기 쉽고, 한 가지 기능에 충실하도록.
- 독립적인 테스트 - 다른 모듈이나 외부 라이브러리를 사용 하는 경계부분을 잘 살펴보자.
- 제어할수 없는 의존성 요소를 주의하자 - `시간, 임의성(random), 동시성, 인프라, 기존 데이터, 영속성(persistency), 네트워킹` 똑같은 세팅에서 똑같은 테스트결과가 나오는지?
- 절대 실패하지 않거나 항상 실패하는 테스트는 하나 마나다.

## 테스트 더블
- 테스트 대상 코드와 그외 코드(의존성, 상호작용 모듈)를 격리한다.
- 테스트 속도 개선하고 예측 불가능한 실행 요소를 제거한다.
- 특수한 상황을 시물레이션한다.
- 테스트 결과정보를 얻기 위한 감춰진 정보를 얻어낸다.(private 멤버를 읽고 쓰는게 필요하다면 대부분 추상화가 덜되었거나 설계가 잘못된 경우이다.)
- **스텁, 가짜 객체** - *테스트 대상이 아닌 코드(의존성,모듈)를 상속을 통해* 아무일 하지 않거나 특정 값을 하드코딩하여 테스트에 사용.
- **스파이** - 테스트 결과를 확인하기 힘들 경우(메소드 리턴값이 없다던가..) *테스트 대상을 상속* 하여 결과를 확인할수 있는 메카니즘을 추가 구현.
- **Mock** - 위의 것들의 구현을 쉽게 만들어줌.

## 테스트 가능 설계
- 단일 책임 원칙 - 클래스는 작고 한가지 역할에만 충실하고 응집력이 높아야 한다.
- 전략(Strategy) 패턴 사용.
- 상위 클래스는 하위 클래스로 대체해도 문제없이 동작해야 한다.
- 하나의 범용 인터페이스보다 쓰임새별로 최적화한 인터페이스 여러 개가 낫다.
- 의존성 주입 사용.
- 모듈화 - 지금 만드는 시스템도 언젠가 더 큰 시스템의 일부로 될수 있도록 설계해야 한다.
- private 멤버는 테스트할 필요가 없도록 설계하자. - private 멤버까지 테스트해야될 생각이 든다면 리팩토링을 고려하자. 해당 부분만 따로 객체로 만들어서 public 을 제공해 테스트 하자.
- 객체 생성(new)은 테스트 더블로 대체할 가능성이 없는 객체만 직접 생성하자. - 테스트할때 그 객체를 다른 걸로 교체할 필요는 없는지 생각해보자.
- 생성자에서는 테스트에서 교체해야 할만한 코드는 넣지 말자. - 외부 파라매터로 입력받게 한거나 오버라이딩 가능한 메서드로 추출하자.
- 싱글톤은 최대한 피하자. - 정 안되면 싱글톤 대상의 클래스는 전략 패턴으로 추출하고 인터페이스를 리턴하도록 구현하자.
- 상속보다는 컴포지션을 이용하자 - [상속의 용도는 다형성이지 코드 재사용이 아니다.](#상속의-용도는-다형성이지-코드-재사용이-아니다) 상속은 테스트 용이성을 떨어뜨릴 수 있다.
- 설계 변경이 불가능한 경우 혹은 외부 라이브러리를 사용할때에는 중간에 테스트하기 쉬운 계층을 하나 만들어서 감싸자.

### 테스트가 불가능한 원인
테스트 용이성을 떨어뜨리거나 아예 테스트 작성을 불가능하게 하는 데는 이러한 문제가 있을수 있다.
- 객체 생성 불가
- 메서드 호출 불가
- 메서드 결과 혹은 부수 효과 확인 불가
- 테스트 더블로 교체 불가
- 메서드 오버라이딩 불가


###### 상속의 용도는 다형성이지 코드 재사용이 아니다.
안타깝게도 많은 개발자가 이를 깨닫지 못하고 클래스에 기능을 추가하는 저렴한 수단쯤으로 상속을 이용한다. 상속은 선택의 폭을 좁혀버린다. 한 클래스의 자식이 되었으니 자연스럽게 다른 클래스를 부모로 모실 기회는 사라진다. 상위 클래스의 생성자에 영구히 묶여버리고 상위 클래스의 API가 변경되면 아무 말 못 하고 따를 수밖에 없다. 컴파일 시에 모든 미래가 결정되는 것이다.  
그에 반해 컴포지션은 더 많은 자유를 안겨준다. 상위 클래스를 호출할 일은 일절 없다. 상속이 상위 클래스의 메서드의 재사용하던 것과 달리 다른 구현을 통해 재사용할 수 있고, 실행 도중에도 마음껏 교체할 수 있다. 이런 이유로 개인적으로는 가능한 한 항시 상속이 아닌 컴포지션으로 문제를 해결한다.(단, 다형성을 줄 수 있는 건 상속뿐이다.) [원문](https://dzone.com/articles/benefits-testable-code)
