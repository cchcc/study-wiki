# Tidy First

https://tidyfirst.bettercode.kr/

## intro
- Tidy vs 기능(동작)
- 코드 정리(Tidy)를 먼저할까? 기능(동작)을 먼저 할까?
- 코드를 변경해야하는데.. 엉망이네 코드 정리부터 하는게 좋을까? 한다면 뭐부터? 어디까지?
  - 이책에서는 위같은 상황에서 이걸 잘 하는 방법을 이야기함

- '경험적' 소프트웨어 설계
  - 무엇 을 설계할것인가가 가장 큰 논쟁
  - 위 논쟁에서 근본적으로 언제 설계할것인가의 의견 차이가 생김
    - 극단적으로 최대한 빨리 설계: 추측형. 일어날 만한것들을 다 추측해서 설계에 녹여냄
    - 극단적으로 최대한 늦게 설계: 반응현. 기능위주로 하다가 기능 추가가 불가능해지는 시기에 그게 해소될 정도로만 설계해서 보완함
  - 언제 설계 할것인가. 위 두가지 사이의 그 어딘가를, 그 시기를 설계하는것

## part 01 코드 정리

### 01 보호 구문
- 일찍 리턴 시키기
```
if (조건 부정) return
if (다른 조건의 부정) return  // 이런 것들을 보호 구문이라고 명칭
```
- 보호구문을 과한건 아닌가? 여기서 보호구문으로 이정도까지 책임져주는게 맞나? 하는 고민도 필요하다
  - 레이어 별 책임
- 보호구문으로 코드의 인지 범위를 집중화 시켜줌

### 02 안쓰는 코드
- 칼 삭, 미련 nono
- 형상 관리를 하고 있으면 복원하기 쉽다
  - 당장 사용하지 않지만 미래에 사용할지도..?
  - 잘 동작 하는거
  - 만들었는데 지우기 아까움..?
  - 지워도 안전하다 라는 확신을 가지려면 undo 에 대한 매카니즘이 있어야함
- 안쓰는 코드를 남겨두었다가 나중에 설계가 변해서 딱 맞지 않는데도 그대로 쓸 가능성이 있다
- 이슈가 생겼을때 안쓰는 코드가 있으면 디버깅하기 까다롭다(이게 쓰이는건지 뭔지..)
  - 이걸 판단하고 고민하는데 '시간' 이 든다
- 안쓰는 라이브러리 제거
  - go 는 언어 차원에서 의존성 관리 툴((Go Module)이 있고, tidy 라는 안쓰는 의존성을 제거해주는 명령어가 있다.

### 03 대칭으로 맞추기
- '대칭' 이라는 단어를 썼지만 일관성에 관한 이야기
  - 일관성덕에 코드를 파악하는데 시간을 조금이라도 줄여주는가
- 코드는 유기적으로 성장한다 -> 뭔소리냐면 같이 코드를 짜는 사람들의 관계도 코드에 반영된다
  - '유기적'이라는 단어에 초점하여 수직적으로 보면 코드가 해결하는 문제는 상위의 비지니스가 가치를 주는 일부이다
- 같은 문제라도 시대와 사람에 따라 다른 모양의 코드가 된다.
  - 혼자 코드를 짜도 같은 문제에 다른 패턴의 코드가 나오기도 한다.
  - 예를 들어 늦은 초기화, 즉 이전 객체가 없으면 새로 만들고 리턴 한다는 문제도 매우 다양한 패턴(뭔가 기교를 부린다거나)으로 만들어 질수 있다
- 이걸 한가지 패턴으로 맞추자. 코드를 읽는 입장에서 일관된 패턴이 나올수록 빠르게 사고 할수 있다
- 다른 패턴이 보이는거를 한가지 패턴으로 코치는 작업을 진행 하자
- 자동화
  - 린트라던가
- 코딩 표준화?
  - 고려할게 꽤 많고 사람에 따라서는 민감한 문제
  - 사람이 얼마나 있나? 코딩 스타일이 얼마나 비슷? 팀원들이 표준화를 원하나? 본인 스타일을 포기할 준비가 되있나?(강요로 억지로 따르게 되는게 맞나?)
  - 스타트업 같이 빠르게 mvp 를 만들고 pmf 를 맞춰나가는게 중요하면 생산성을 최대한 발휘하는게 나은 선택일수 있다
  - 자율성 창의성이 주어질수록 주도적으로 일하는 경향 고려
- 코드의 일관화 보다 아키텍쳐 수준에서 일관화가 좀더 에측/판단에 좀더 효율적

### 04 새로운 인터페이스로 기존 루틴 부르기
- 기존꺼를 호출하려는데 복잡, 어렵, 혼란, 지루(?) 하다면 새로 만들어보기
  - 지루하다는게.. 개인능력이 높아서 
- 어댑터, 파사드 패턴 비슷
- 다른 비슷한 느낌의 기법
  - 거꾸로 코딩: 함수의 마지막줄. 리턴해야 되는걸 먼저짜보기
  - 테스트 퍼스트: 테스트 코딩부터 짜보기
  - 도우미 설계: 
    - 헬퍼 vs 유틸
      - 공통점: 둘다 주요한 로직이 아닌 기능성 동작을 작성하는데 이 이름을 붙임
      - 다른점: 헬퍼는 static 뿐만 아니라 객체화도 가능, 내부 필드 가질수 있음. 유틸은 오로지 static 만 사용함

#### 몰입 이론(Flow Theory)
- 일의 어려운 정도 : 개인의 능력
- 위 두가지를 xy 그래프로 잡았을때 그 비율이 맞을때 몰입 할수 있다는..

### 05 읽는 순서
- 독자의 입장에서 코드를 작성하자: 읽는 순서를 고려해서 작성하자
  - 전체를 이해하는데 중요한 사항이 마지막에 오는게 좋은 방법일까?
  - 코드가 목적에 맞게 동작하는가(실행한다)와 코드가 깨끗한가(잘 나타있는가) 는 다른 문제
- 코드 작성의 목적(다른 사람이 읽게되는 목적)에 코드 정리 작업을 섞지 말자
  - 이건 PR 단위로 하는게 맞을듯
- 언어에 따라 선언하는 순서에 따라 결과가 달라지는 경우도 있다. 이런 경우는 주의
- 완벽한 순서를 정하는 방법은 없다
  - 기본 요소를 이해후 구성 방법을 하는게 좋을때도, api 먼저 이해후 세부구현을 이해하는게 좋을때도
  - 어떤 순서의 코드가 이해하는데 좋을지 
- 코드의 가독성: 사람의 인지 부하를 낮추는 방법
- 잘 정돈된 코드는 그 다음사람으로 하여금 비슷한 패턴으로 작성되도록 한다
- 이런것들 고민할 시간에 피쳐 하나라도 더 만드는게 의미 있는거 아닌가?
  - 궁극적으로는 이런 행동들이 몸에 베여 고민할 시간 들이지 않고 자연스럽게 나오도록 훈련이 필요(내)
- 실천적 방법들
  - A 함수에서 B 함수를 호출한다면 B 함수는 A 함수 바로 밑에다 작성
  - 개념단위를 행으로 구분
  - 밀접한 개념은 서로 가까이에 두기
  - 변수는 사용하는 위치에 최대한 가까이 두기
  - 이러한 것들들의 패턴을 일관되게 유지

### 06 응집도를 높이는 배치
- 코드를 변경하려고 했더니 여기저기 흩어져 있다면? -> 변경할 것들은 최대한 가까운 위치에 배치. 같은 파일, 같은 디렉토리
- 결합도 제거 + 변경 하는 비용 < 결합도 유지 + 변경 비용 ??
- 결합도를 제거하기 어려운 이유
  - 당장 어떻게 할지 모르는 경우
  - 시간적 여유가 없을때
  - 팀원 간의 잠재적 갈등 - 설계가 자주 바뀌어 적응 못한다거나 못 받아 들인다거나..
    - 팀에 스트레스를 줄수 있는 상황이면 안하는게 나을지도
- 응집도를 모은다고 해봣더니 나중에 알고보면 결합도만 들어나느경우? -> 문맥의 경계를 잘 정의 해야함
- 같은 이유로 변경되는 것을 모은다(SRP 비슷), 의존성을 낮춘다, 외부에 불필요한 정보는 private(캡슐화) -> 응집도를 높인다

### 07 선언과 초기화를 함께 옮기기
- 변수를 처음부터 선언하지 말고 필요한 시점에 선언해서 사용하기
- 커다란 설계, 변경이 무서우면 무섭지 않을정도의 더 작은 단계로 해보자자

### 08 설명하는 변수
- 코드의 어떤 표현식들은 시간이 지나면서 점점 길어진다. 이런것들은 적절한 변수명으로 선언을 해주자
- if, switch 에 들어가는 것들이 이런식으로 쓰기 좋다
- 선언형 스타일
- 변수명으로 설명하면 가독성이 높아진다

### 09 설명하는 상수
- 리터럴이라고 그냥 바로 상수로 지정하는 것 보다는 의미를 명확히 주는 상수명을 만들어야 한다
- 빈약한 의미의 상수 예:  1 = ONE
- 매직 넘버
  - 설명없이 뜬금 등장하는 타입별 구분 상수값. 예를 들어 1은 사용자 2는 어드민 3은 구독자 등
  - 비트 연산을 이용해 비트 단위로 특정 위치에 해당 비트가 있는지 확인용
  - 특정 위치에 특정 값이 있으면 확인용(비트 연산 확인 기법이랑 비슷)
- 코드 정리법으로서 한번에 바뀌거나 함께 이해해야 하는것들은 한곳에 모으고, 아닌 변수들은 분리
  - 모든 상수를 한곳에 모아두는것은 좋은 방법이 아닌

### 10 명시적인 매개변수
- 함수의 인자가 명시적이지 않다? 매개변수를 그냥 map 하나로 전달
  - 일단 뭐가 필요한건지 함수만 인지가 어렵다
  - map 내부에서 키등을 변경하면 유지보수등이 더욱 어려워진다
- 당장 바꾸기 어려우면 내부에서 명시적으로 map 을 분해해서 각 매개변수로 호출하는 함수를 다시 만들자
  - 이렇게 하면 최소 읽기, 테스트, 분석이 쉬워짐
- 전달해야 되는 매개변수가 많아서 map 을 썻다? 그러면 함수의 파라매터 갯수는 몇개가 적당한가?
  - 인간 인지능력을 연구한것에 의하면 단기적인 갯수로 4개쯤이 적당. 5개가 넘어가면 vo 로 만들어 볼것을 고려하라
  - map 이 아니라 하나의 의미로 뭉쳐진 vo 로 만들어라
  - 매개 변수가 너무 많은거 같으면 만들려는 함수가 너무 큰 책임을 가지고 있는거 아닌지 고민해봐라

### 11 비슷한 코드끼리
- 개념적으로 분리가 가능한곳에는 빈줄을 넣어서 분리하자.
  - personal: 함수로 나누라는게 아님 빈줄을 넣으라는 거
  - 당연한거 같은데 켄트벡같은 쌉고수도 이걸 언급을 함
- 비슷한거를 한곳에 뭉쳐둔다 라는 의미. 이거시 코드를 정리하고 설계하는 방법이 아닐까

### 12 도우미 추출
- 목적이 분명하고 나머지 코드와는 상호작용이 적은 코드 블럭이 있다 -> 도우미로 추출하고 작동 방식이 아니라 목적에 따라 명명한다
  - 메서드 추출 리팩터팅 방법이라고도 함
- 함수 명 짓기
  - how 보다는 why 즉 목적에 따라 짓는게 좋다
  - how 로 지으면 함수내 코드 내용이 바뀌면 함수명도 바꿔야함
- 함수가 순서대로 호출되야 하는 경우(선후관계가 있는 경우)도 헬퍼로 추출하기가 좋다
  - 시간적인 의존성?

### 13 하나의 더미
- 여기저기 흩어져 있는 코드를 하나로 모으기
  - 복잡한 로직 혹은 의미 해석이 어려운경우
- 작은 코드 조각을 지향하는 목적은 코드를 한 번에 조금씩 이해할수 있도록 하는것
  - 근데 이게 잘못될수도 있다
- 이러한 증상일때 고려해보자
  - 길고 반복되는 인자
  - 반복되는 코드, 그중에서도 반복되는 조건문
  - 부적절한 도우미의 이름
  - 불필요하게 변경에 노출된 데이터 구조

### 14 설명하는 주석
- 명확하지 않는 내용만, 이코드를 처음 읽는 사람이라고 가정, 미리 알았더라면 좋았을점, 
- 문제점을 발견한 경우(수정하는게 바람직하지만 수정하기 전까지는 미리 지적해두는것이 필요함)
- 어떻게 해야 하는가 보다 왜(why) 하는가를 작성하는게 더 효율적
- 주석도 코드의 일부이다. 무엇을 주석으로 남길건지도 설계의 영역
- 주석이 가짜정보가 되지 않도록 주의: 코드가 변경되면 주석도 같이 변경하도록
- 다른 사람의 관점에서 생각하는게 핵심

### 15 불필요한 주석 지우기
- 코드를 작성하는 목적은 다른 프로그래머가 컴퓨터가 해야 할 일을 설명하는 데 있다
  - 컴퓨터에게 지시하는 용도가 아니라..?
- 읽는 사람의 시간만 뺏는 주석은 삭제
- 코드의 표현력이 충분하다면 주석은 불필요
  - 코드가 좀 이상한데 주석으로 명쾌하게 설명이 가능?
- 주석 자체를 완전 부정적으로 생각할 필요는 없
  - 코드를 주석 필요 없을정도로 잘 짜면 되지않냐 던가

## part 02 관리
- 코드 정리는 언제 시작?
- 코드 정리는 언제 멈춤?
- 코드 정리 작업과 동작 변경 작업을 어떻게 결합?

### 16 코드 정리 구분
- pr 을 올리때 동작 변경, 구조 변경을 같이 하면 리뷰어가 힐들어 한다: 섞지 말라
- 동작 변경, 구조 변경을 구분해서 각각 pr 하는것을 권장
  - 인간 관계를 고려한 거임
- 하지만 하나로 만들어 할지 여러개로 잘게 할지는 장단점이 있다
  - 작은 규모로 보는 이점
  - 작은 규모인데 빠르게 리뷰가 안이루어 지면(다음 작업 진행까지 대기..) 업무 진행이 느려짐
- 이런 방식을 하려면 하려는 일하는 환경, 프로세스, 문화가 다 받춰줘야 가능
- 인간 관계내에서 나(조직)에게 맞는 방식을 찾기
  - 핵심은 작업을 더 효율적으로 만드는 새로운 기능을 실험하고 찾는 것

### 17 연쇄적인 정리
- 정리를 한번하면 뭔가 계속 하게됨. 어떤걸 하는건지 목적 or 범위를 정해보자
  - 하나를 정리 하면 이후에 가능한 선택지가 늘어남
  - part 01 에 있는 실천 방법들이 이에 해당함
- 너무 많이 빠르게 변경하지 않도록 주의하자. 
- 대체로 작게 변경해서 성공해 나가는것이 무리하게 한방에 하다 실패하는거 보다 시간을 아껴준다
- 실제로 실천하는게 중요. part 01 것들에 대한게 있는지 훑어보고 시도해보자
- 얼마정도의 크기로 하나? 들어가는 시간을 기준으로?
  - 작은 단계로 실험해가면서 최적화해라

### 18 코드 정리의 일괄 처리량
- 코드 정리의 크기는 어느 정도가 적절할까?
  - 다음 동작 변경을 위한 작업이라면 어느정도까지가 적절할까?
- 크기를 정하는데 고려할만한 것들
  - 충돌: 양이 많을수록 가능성이 커짐
  - 상호작용: 다른 동작을 건드릴 가능성. 많을 수록 커짐
  - 추측: 양이 많을 수록 어려움. 동작 변경에 도움이 될만큼이 아니면 다른 예상치 못한 일이 일어날 가능성이 높아짐
  - 검토: 이건 기본적으로 고정비용이 있음. 횟수가 많을수록(즉 크기가 적을수록) 비용이 늘어남.
- 충돌, 상호작용, 추측은 크기를 작게 해서 낮추고 검토비용을 줄이는 방향
  - 팀에 신뢰와 강력한 문화가 있으면 코드 정리는 검토할 필요가 없다
  - 테스트 코드, 자동화, ci/cd 파이프라인 등의 안전장치
  - 실천하고 실험하고 팀과 같이 시행착오를 검토하면서 신뢰를 쌓아가자. 몇달은 걸림

### 19 리듬
- 코드 정리를 할때는 어느 정도 시간을 들이는게 나을까?
  - 분단위. 한시간 미만으로 하는게 적절
- 언제 멈추는게 나을까의 이야기
- 길게 한번에 크게하는거 보다는 점진적으로 맞춰 나가는
  - 제작자가 설계의도와는 다르게 사용자들이 많이 사용하는 것
- 소프트웨어 설계는 프랙탈 이므로 크기는 작게도 크게도 가능
  - 어느 한쪽의 해결방법이 다른 부분에도 유효할수 잇다. 크기가 다를뿐. 이것을 찾아 내는것이 중요

### 20 얽힘 풀기
- 동작 변경을 하다보니 코드 정리를 해야 하는걸 깨달은 경우 어쩌지?
  - 코드 정리와 동작 변경이 공존 해버림
- 선택지
  - 그대로 배포. 오류 가능성. 팀원이 안좋아함
  - pr 을 나눔, pr 하나에 여러 커밋으로 여러번 리뷰. 무례함은 줄이지만 작업 횟수는 늘어남
  - 진행 중이던걸 버림. 코드 정리를 먼저 pr 해서 끝내고, 동작 변경을함
- 3번 ㄱㄱ. 이미 작업한거? 매몰 비용 아까워 하지 마셈
- 딴이야기 인데 셋다 시도해보고 셋다 실패해봐도 된다. 여기서 충분히 교훈을 얻을수 있다 by xp

### 21 코드 정리 시점
- 코드 정리를 먼저하고 동작 변경을 할까? 동작 변경을 하고 코드 절리를 할까? 아예 안할까?
- 아예 안한다: 이런 경우는 드물긴한데. 엉망이어도 이게 앞으로 변경할 일이 없을거라는 믿음이 있으면 괜찮.
- 그냥 나중에 한다: ㄹㅇ 나중에 하긴할건가? 일을 할수 있는 시간이 진짜 충분한가?
  - 나중에 동작 변경이 이루어질게 확정된 곳. 동작 변경을 더 쉽게 만든다
  - 리스팅을 해두고 하나씩 진행함
  - 재미 목록: 나중에 자신이 원할떄 의욕적일때 하면 더 기분이 좋다. 우리는 인간이고 이를 통해 행복, 기쁨 느낀다
- 동작 변경 직후에 한다: 나중에 했다가 맥락을 잃어버릴수도, 나중에 기다리리는 비용이 더 클수도, 
  - 방금 고친 코드가 근미래에 다시 변경 예정인경우
  - 지금 정리하는게 저렴할때
  - 코드 정리에 드는 시간이랑 동작 변경 시간이랑 비슷할때
  - 시간이 너무 오래 걸릴거 같으면 그냥 나중에
- 코드 정리후 동작 변경: 
  - 코드 정리의 이점을 즉각적으로 얻을수 있으면 한다.
  - 코드 정리를 통해 앞으로 얻을수 있는 이득이 크면 한다. 근데 적거나 아예 없으면 비용을 따져보자
- 요약
  - 하지마: 해당 부분이 앞으로 다시는 변경이 없을때. 설계를 개선해도 배울만한게 없을때
  - 나중에 해: 하고난 보상이 바로 없거나 잠재적일때, 양이 커서 작은 묶음으로 여러번 나눠서 해야할때
  - 동작 변경후에 해: 다음 코드 정리까지 기다릴수록 비용이 늘어날때, 이거 까지 해야 일이 끝난 느낌일때(ㅎㅎ)
  - 동작 변경전에 해: 코드 정리를 해서 즉각적인 효과를 얻을때, 어떻게 정리할지 정확히 알고 있을때(하다보니 깨닫는게 아닌)

## part 03 이론
- 소프트웨어 설계 언제할지, 장단점?
- 소프트웨어 설계는 인간관계 속에서 벌어지는 활동

### 22 요소들을 유익하게 관계 맺는 일
- 이거시 소프트웨어 설계의 정의
- 변화를 위한 준비. 동작 변경에 대한 준비
### 요소
- 프로그래밍 에서의 요소
  - 토큰 -> 식 -> 문 -> 함수 -> 객체/모듈 -> 시스템
  - 요소는 하위요소를 포함함. 계층 구조를 이룸
#### 관계 맺기
- 요소들간의 관계가 생김
- 관계 종류: 호출, 발행(publish), 대기(listen), 참조(변수 값 가져오기)
#### 유익하게
- 설계자는 이런 행동을 할수 있다
  - 요소를 생성 or 삭제
  - 관계를 생성 or 삭제
  - 관계의 이점을 높인다

- 요소에 계층 구조라는게 존재, 요소 사이에 관계라는게 있고, 이러한 관계가 만들어내는 이점

### 23 구조와 동작
- 소프트웨어가 만드는 가치의 2가지 방식
  - 현재 소프트웨어가 하는일  -> 동작에 관련함
  - 미래에 새로운걸 할수 있는 가능성  -> 구조에 관련함
- 소프트웨어를 만들어가는데 선택 가능성을 줄이는 상황은 여러가지. 예를 들어
  - 핵심 개발자 퇴사
  - 고객의 니즈 변화
  - 변경하는데 비용이 많이 들어감(이러면 비지니스의 선택 주기나 선택지가 줄어듬): 이 이야기는 이거에 관한거임
- 구조를 변경하더라고 동작에는 아무 영향이 없다(없어야 한다)
  - 뭐 레이어를 몇개로 나누든 클래스를 뭐 어떻게 하던..
- 구조를 변경하는것은 미래에 어떤 동작에 대한 '선택지' 를 늘려주는 것이다
  - 구조에 따라 미래의 변화에 대한 대응이 쉬워질수도 있고 어려워 질수도 있다
- 동작과 구조는 둘다 가치를 만들어 내지만 근본적으로 다르다는걸 이해해야함
  -> 그것은 가역성(되돌릴수 있는 능력) 이다

### 24 경제이론: 시간 가치와 선택 가능성
- 버는것은 최대한 빨리 하고 쓰는것은 최대한 미룬다
- 미래에 대한 불확실이 높을수록 물건 자체보다는 옵션(선택지)이 많은 것이 낫다
- 위 두가지를 잘 조화시켜야 함

### 25 오늘의 1달러가 내일의 1달러보다 크다
### 26 옵션
- 대충.. 경제/금융 이야기(콜옵션, 현금흐름할인)
- 더 많이, 더 일찍, 더 높은 확률도 돈을 벌 수 있다
- 더 적게, 더 늦게, 더 낮은 확률로 돈을 지출 할수 있다
- 불확실성이 높으면 선택지를 늘리는 방법
-> 부를 축적하는(가치를 만드는) 원리에 가까운데 이걸 소프트에어 관점에서 생각

### 27 옵션과 현금흐름 비교
- 코드 정리가 먼저인가?
  - 코드 정리 비용 + 이후에 이어지는 동작 변경 비용 < 바로 동작 변경하는 비용 -> 이러면 당연히 코드 정리를 먼저 한다
- 코드 정리 비용 + 이후에 이어지는 동작 변경 비용 > 바로 동작 변경하는 비용 -> 이럴때 어떡할지 판단이 필요하다
  - 경제성을 정확하게 계산할 수 없고, 시도해서도 안됨
- 두 가지 중요한 형태의 판단력을 키워야함: 꾸준히 연습하다 보면 직감적으로 알 수 있게 된다
  - 소프트웨서 설계의 임팩트를 인식하는데 익숙해지기(여기에 투자하는것이 어떻게 영향을 미칠지)
  - 대인 관계 기술을 우리 자신에게 연습, 그리고 더 나아가 동료, 동료의 동료까지 활용하기

### 28 되돌릴 수 있는 구조 변경
- 되돌릴수 있는것과 없는것은 다르게 취급해야한다
- 코드 정리는 동작변경과 다르게 되돌리기가 쉽다
- 되돌릴수 있는것에 대한 작업, 그리고 코드 검토에 지나치게 시간을 들일 필요가 없다.
- 이거시 가역성
- 되돌릴수 없는 소프트웨어 설계에 주의

### 29 결합도
- 하나를 변경하려는데 연쇄적으로 변경하는거
- 종속성

### 30 콘스탄틴의 등가성
- 비싼 소프트웨어 = 하나를 변경하면 많이 변경해야한다
- 비싼 소프트웨어 = 결합도가 높은거

### 31 결합도와 결합도 제거
- 결합도가 생겨도 빠르게 코드를 작성하는것이 경제성이 있을수 있다.
- 어떨때는 특정 결합도를 줄이면 다른데서 결합도가 올라갈수도 있다.

### 32 응집도
- 결합된 하위 요소들은 같은 요소 하위에 위치함

### 33 결론
- 코드 정리가 먼저인가?
  - 비용, 수익, 결합도, 응집도 를 고려한다
  - 그리고 나 자신도 고려한다. 평화, 만족, 기쁨을 누리면서 일하고 있는가
  - 들뜬 기분에 코드 정리에 집착해서 과하게 하지 않도록 주의
- 나 -> 나와 동료 프로그래머 -> 모든 이해관계자
- 코드 정라 -> 리팩토링 -> 아키텍쳐의 진화
- 몇 분/시간 -> 몇 일/주 -> 몇 달/년
- 소프트웨어 설계를 비지니스 전략 계획의 일부로 생각
  - 기술 지향적 사람들과 비지니스 지향적 사람들과의 관계

#### 도서
- 쏙쏙 들어오는 함수형 코딩
- Code That Fits in Your Head
- 프로그래밍 심리학
- Structured Design
