# Tidy First

https://tidyfirst.bettercode.kr/

## intro
- Tidy vs 기능(동작)
- 코드 정리(Tidy)를 먼저할까? 기능(동작)을 먼저 할까?
- 코드를 변경해야하는데.. 엉망이네 코드 정리부터 하는게 좋을까? 한다면 뭐부터? 어디까지?
  - 이책에서는 위같은 상황에서 이걸 잘 하는 방법을 이야기함

- '경험적' 소프트웨어 설계
  - 무엇 을 설계할것인가가 가장 큰 논쟁
  - 위 논쟁에서 근본적으로 언제 설계할것인가의 의견 차이가 생김
    - 극단적으로 최대한 빨리 설계: 추측형. 일어날 만한것들을 다 추측해서 설계에 녹여냄
    - 극단적으로 최대한 늦게 설계: 반응현. 기능위주로 하다가 기능 추가가 불가능해지는 시기에 그게 해소될 정도로만 설계해서 보완함
  - 언제 설계 할것인가. 위 두가지 사이의 그 어딘가를, 그 시기를 설계하는것

## p1 코드 정리

### 01 보호 구문
- 일찍 리턴 시키기
```
if (조건 부정) return
if (다른 조건의 부정) return  // 이런 것들을 보호 구문이라고 명칭
```
- 보호구문을 과한건 아닌가? 여기서 보호구문으로 이정도까지 책임져주는게 맞나? 하는 고민도 필요하다
  - 레이어 별 책임
- 보호구문으로 코드의 인지 범위를 집중화 시켜줌

### 02 안쓰는 코드
- 칼 삭, 미련 nono
- 형상 관리를 하고 있으면 복원하기 쉽다
  - 당장 사용하지 않지만 미래에 사용할지도..?
  - 잘 동작 하는거
  - 만들었는데 지우기 아까움..?
  - 지워도 안전하다 라는 확신을 가지려면 undo 에 대한 매카니즘이 있어야함
- 안쓰는 코드를 남겨두었다가 나중에 설계가 변해서 딱 맞지 않는데도 그대로 쓸 가능성이 있다
- 이슈가 생겼을때 안쓰는 코드가 있으면 디버깅하기 까다롭다(이게 쓰이는건지 뭔지..)
  - 이걸 판단하고 고민하는데 '시간' 이 든다
- 안쓰는 라이브러리 제거
  - go 는 언어 차원에서 의존성 관리 툴((Go Module)이 있고, tidy 라는 안쓰는 의존성을 제거해주는 명령어가 있다.

### 03 대칭으로 맞추기
- '대칭' 이라는 단어를 썼지만 일관성에 관한 이야기
  - 일관성덕에 코드를 파악하는데 시간을 조금이라도 줄여주는가
- 코드는 유기적으로 성장한다 -> 뭔소리냐면 같이 코드를 짜는 사람들의 관계도 코드에 반영된다
  - '유기적'이라는 단어에 초점하여 수직적으로 보면 코드가 해결하는 문제는 상위의 비지니스가 가치를 주는 일부이다
- 같은 문제라도 시대와 사람에 따라 다른 모양의 코드가 된다.
  - 혼자 코드를 짜도 같은 문제에 다른 패턴의 코드가 나오기도 한다.
  - 예를 들어 늦은 초기화, 즉 이전 객체가 없으면 새로 만들고 리턴 한다는 문제도 매우 다양한 패턴(뭔가 기교를 부린다거나)으로 만들어 질수 있다
- 이걸 한가지 패턴으로 맞추자. 코드를 읽는 입장에서 일관된 패턴이 나올수록 빠르게 사고 할수 있다
- 다른 패턴이 보이는거를 한가지 패턴으로 코치는 작업을 진행 하자
- 자동화
  - 린트라던가
- 코딩 표준화?
  - 고려할게 꽤 많고 사람에 따라서는 민감한 문제
  - 사람이 얼마나 있나? 코딩 스타일이 얼마나 비슷? 팀원들이 표준화를 원하나? 본인 스타일을 포기할 준비가 되있나?(강요로 억지로 따르게 되는게 맞나?)
  - 스타트업 같이 빠르게 mvp 를 만들고 pmf 를 맞춰나가는게 중요하면 생산성을 최대한 발휘하는게 나은 선택일수 있다
  - 자율성 창의성이 주어질수록 주도적으로 일하는 경향 고려
- 코드의 일관화 보다 아키텍쳐 수준에서 일관화가 좀더 에측/판단에 좀더 효율적

### 04 새로운 인터페이스로 기존 루틴 부르기
- 기존꺼를 호출하려는데 복잡, 어렵, 혼란, 지루(?) 하다면 새로 만들어보기
  - 지루하다는게.. 개인능력이 높아서 
- 어댑터, 파사드 패턴 비슷
- 다른 비슷한 느낌의 기법
  - 거꾸로 코딩: 함수의 마지막줄. 리턴해야 되는걸 먼저짜보기
  - 테스트 퍼스트: 테스트 코딩부터 짜보기
  - 도우미 설계: 
    - 헬퍼 vs 유틸
      - 공통점: 둘다 주요한 로직이 아닌 기능성 동작을 작성하는데 이 이름을 붙임
      - 다른점: 헬퍼는 static 뿐만 아니라 객체화도 가능, 내부 필드 가질수 있음. 유틸은 오로지 static 만 사용함

#### 몰입 이론(Flow Theory)
- 일의 어려운 정도 : 개인의 능력
- 위 두가지를 xy 그래프로 잡았을때 그 비율이 맞을때 몰입 할수 있다는..

### 05 읽는 순서
- 독자의 입장에서 코드를 작성하자: 읽는 순서를 고려해서 작성하자
  - 전체를 이해하는데 중요한 사항이 마지막에 오는게 좋은 방법일까?
  - 코드가 목적에 맞게 동작하는가(실행한다)와 코드가 깨끗한가(잘 나타있는가) 는 다른 문제
- 코드 작성의 목적(다른 사람이 읽게되는 목적)에 코드 정리 작업을 섞지 말자
  - 이건 PR 단위로 하는게 맞을듯
- 언어에 따라 선언하는 순서에 따라 결과가 달라지는 경우도 있다. 이런 경우는 주의
- 완벽한 순서를 정하는 방법은 없다
  - 기본 요소를 이해후 구성 방법을 하는게 좋을때도, api 먼저 이해후 세부구현을 이해하는게 좋을때도
  - 어떤 순서의 코드가 이해하는데 좋을지 
- 코드의 가독성: 사람의 인지 부하를 낮추는 방법
- 잘 정돈된 코드는 그 다음사람으로 하여금 비슷한 패턴으로 작성되도록 한다
- 이런것들 고민할 시간에 피쳐 하나라도 더 만드는게 의미 있는거 아닌가?
  - 궁극적으로는 이런 행동들이 몸에 베여 고민할 시간 들이지 않고 자연스럽게 나오도록 훈련이 필요(내)
- 실천적 방법들
  - A 함수에서 B 함수를 호출한다면 B 함수는 A 함수 바로 밑에다 작성
  - 개념단위를 행으로 구분
  - 밀접한 개념은 서로 가까이에 두기
  - 변수는 사용하는 위치에 최대한 가까이 두기
  - 이러한 것들들의 패턴을 일관되게 유지

### 06 응집도를 높이는 배치
- 코드를 변경하려고 했더니 여기저기 흩어져 있다면? -> 변경할 것들은 최대한 가까운 위치에 배치. 같은 파일, 같은 디렉토리
- 결합도 제거 + 변경 하는 비용 < 결합도 유지 + 변경 비용 ??
- 결합도를 제거하기 어려운 이유
  - 당장 어떻게 할지 모르는 경우
  - 시간적 여유가 없을때
  - 팀원 간의 잠재적 갈등 - 설계가 자주 바뀌어 적응 못한다거나 못 받아 들인다거나..
    - 팀에 스트레스를 줄수 있는 상황이면 안하는게 나을지도
- 응집도를 모은다고 해봣더니 나중에 알고보면 결합도만 들어나느경우? -> 문맥의 경계를 잘 정의 해야함
- 같은 이유로 변경되는 것을 모은다(SRP 비슷), 의존성을 낮춘다, 외부에 불필요한 정보는 private(캡슐화) -> 응집도를 높인다

### 07 선언과 초기화를 함께 옮기기
- 변수를 처음부터 선언하지 말고 필요한 시점에 선언해서 사용하기
- 커다란 설계, 변경이 무서우면 무섭지 않을정도의 더 작은 단계로 해보자자

### 08 설명하는 변수
- 코드의 어떤 표현식들은 시간이 지나면서 점점 길어진다. 이런것들은 적절한 변수명으로 선언을 해주자
- if, switch 에 들어가는 것들이 이런식으로 쓰기 좋다
- 선언형 스타일
- 변수명으로 설명하면 가독성이 높아진다

### 09 설명하는 상수
- 리터럴이라고 그냥 바로 상수로 지정하는 것 보다는 의미를 명확히 주는 상수명을 만들어야 한다
- 빈약한 의미의 상수 예:  1 = ONE
- 매직 넘버
  - 설명없이 뜬금 등장하는 타입별 구분 상수값. 예를 들어 1은 사용자 2는 어드민 3은 구독자 등
  - 비트 연산을 이용해 비트 단위로 특정 위치에 해당 비트가 있는지 확인용
  - 특정 위치에 특정 값이 있으면 확인용(비트 연산 확인 기법이랑 비슷)
- 코드 정리법으로서 한번에 바뀌거나 함께 이해해야 하는것들은 한곳에 모으고, 아닌 변수들은 분리
  - 모든 상수를 한곳에 모아두는것은 좋은 방법이 아닌

### 10 명시적인 매개변수
- 함수의 인자가 명시적이지 않다? 매개변수를 그냥 map 하나로 전달
  - 일단 뭐가 필요한건지 함수만 인지가 어렵다
  - map 내부에서 키등을 변경하면 유지보수등이 더욱 어려워진다
- 당장 바꾸기 어려우면 내부에서 명시적으로 map 을 분해해서 각 매개변수로 호출하는 함수를 다시 만들자
  - 이렇게 하면 최소 읽기, 테스트, 분석이 쉬워짐
- 전달해야 되는 매개변수가 많아서 map 을 썻다? 그러면 함수의 파라매터 갯수는 몇개가 적당한가?
  - 인간 인지능력을 연구한것에 의하면 단기적인 갯수로 4개쯤이 적당. 5개가 넘어가면 vo 로 만들어 볼것을 고려하라
  - map 이 아니라 하나의 의미로 뭉쳐진 vo 로 만들어라
  - 매개 변수가 너무 많은거 같으면 만들려는 함수가 너무 큰 책임을 가지고 있는거 아닌지 고민해봐라

### 11 비슷한 코드끼리
- 개념적으로 분리가 가능한곳에는 빈줄을 넣어서 분리하자.
  - personal: 함수로 나누라는게 아님 빈줄을 넣으라는 거
  - 당연한거 같은데 켄트벡같은 쌉고수도 이걸 언급을 함
- 비슷한거를 한곳에 뭉쳐둔다 라는 의미. 이거시 코드를 정리하고 설계하는 방법이 아닐까

### 12 도우미 추출
- 목적이 분명하고 나머지 코드와는 상호작용이 적은 코드 블럭이 있다 -> 도우미로 추출하고 작동 방식이 아니라 목적에 따라 명명한다
  - 메서드 추출 리팩터팅 방법이라고도 함
- 함수 명 짓기
  - how 보다는 why 즉 목적에 따라 짓는게 좋다
  - how 로 지으면 함수내 코드 내용이 바뀌면 함수명도 바꿔야함
- 함수가 순서대로 호출되야 하는 경우(선후관계가 있는 경우)도 헬퍼로 추출하기가 좋다
  - 시간적인 의존성?

### 13 하나의 더미
- 여기저기 흩어져 있는 코드를 하나로 모으기
  - 복잡한 로직 혹은 의미 해석이 어려운경우
- 작은 코드 조각을 지향하는 목적은 코드를 한 번에 조금씩 이해할수 있도록 하는것
  - 근데 이게 잘못될수도 있다
- 이러한 증상일때 고려해보자
  - 길고 반복되는 인자
  - 반복되는 코드, 그중에서도 반복되는 조건문
  - 부적절한 도우미의 이름
  - 불필요하게 변경에 노출된 데이터 구조